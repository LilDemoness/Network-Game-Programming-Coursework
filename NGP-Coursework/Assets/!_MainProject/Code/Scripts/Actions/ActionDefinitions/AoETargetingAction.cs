using System.Collections.Generic;
using UnityEngine;
using Gameplay.Actions.Effects;
using Gameplay.GameplayObjects.Character;
using System;

namespace Gameplay.Actions.Definitions
{
    /// <summary>
    ///     An action that always targets itself.
    /// </summary>
    [CreateAssetMenu(menuName = "Actions/AoE Action", order = 4)]
    public class AoETargetingAction : ActionDefinition
    {
        [Header("Targeting")]
        [SerializeReference, SubclassSelector] private AoETargeting _targetingMethod;
        public string GetRangeString(string distanceUnits) => _targetingMethod.GetRangeString(distanceUnits);


        public override bool OnStart(ServerCharacter owner, ref ActionRequestData data) => ActionConclusion.Continue;
        public override bool OnUpdate(ServerCharacter owner, ref ActionRequestData data, float chargePercentage = 1.0f)
        {
            _targetingMethod.GetTargets(owner, base.GetActionOrigin(ref data), base.GetActionDirection(ref data), chargePercentage, callback: (ServerCharacter owner, ActionHitInformation hitInfo) => ProcessTarget(owner, hitInfo, chargePercentage));

            return ActionConclusion.Continue;
        }
        private void ProcessTarget(ServerCharacter owner, in ActionHitInformation hitInfo, float chargePercentage)
        {
            Debug.Log($"{hitInfo.Target.name} was hit!");
            Debug.DrawRay(hitInfo.HitPoint, hitInfo.HitNormal, Color.red, 1.0f);
            Debug.DrawRay(hitInfo.HitPoint, hitInfo.HitForward, Color.yellow, 1.0f);

            for (int i = 0; i < ActionEffects.Length; ++i)
            {
                ActionEffects[i].ApplyEffect(owner, hitInfo, chargePercentage);
            }
        }



        // Sphere, Line, Cone.
        private abstract class AoETargeting
        {
            public abstract string GetRangeString(string distanceUnits);

            [SerializeField] protected bool CanTargetOwner;

            [Space(5)]
            [SerializeField] protected bool ScaleRadiusWithChargePercentage;

            [Space(5)]
            [SerializeField] protected bool RequireLineOfSight;
            [SerializeField] protected LayerMask ObstructionsMask;

            [Space(5)]
            [SerializeField] protected LayerMask ValidLayers;



            /// <summary>
            ///     Finds all valid targets and calls the 'callback' function for the ActionHitInformation generated by each.
            /// </summary>
            /// <remarks> The 'HitForward' of the generated ActionHitInformation will always correspond to the target's up.</remarks> // We did it this way for consistency between angles.
            public abstract void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, System.Action<ServerCharacter, ActionHitInformation> callback);


            /// <summary>
            ///     Is this target valid given an owner check?
            /// </summary>
            /// <returns> True if the target isn't a child of the owner, OR we're not caring about owner checks. Otherwise, false.</returns>
            protected bool IsValidForOwnerCheck(ServerCharacter owner, Transform potentialTarget) => CanTargetOwner || !potentialTarget.HasParent(owner.transform);
            /// <summary>
            ///     Is this target valid given an obstruction check?
            /// </summary>
            /// <returns> True if the target isn't obstructed, OR if we're not caring about obstruction checks. Otherwise, false</returns>
            protected bool IsValidForObstructionCheck(in Vector3 origin, Transform potentialTarget, in Vector3 hitPoint)
            {
                if (!RequireLineOfSight || !Physics.Linecast(origin, hitPoint, out RaycastHit hitInfo, ObstructionsMask, QueryTriggerInteraction.Ignore))
                    return true;    // We aren't caring about obstruction checks OR we didn't find any obstructions.

                if (hitInfo.transform == potentialTarget)
                    return true;    // The discovered obstruction was the target, so no obstructions are between them and the origin.

                return false;   // Obstructed by something other than the target.
            }
        }
        [System.Serializable]
        private class SphereAoETargeting : AoETargeting
        {
            public override string GetRangeString(string distanceUnits) => _sphereRadius + distanceUnits + " Sphere";

            [SerializeField] private float _sphereRadius;

            public override void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, System.Action<ServerCharacter, ActionHitInformation> callback)
            {
                float radius = ScaleRadiusWithChargePercentage ? _sphereRadius * chargePercentage : _sphereRadius;
                foreach(Collider potentialTarget in Physics.OverlapSphere(origin, radius, ValidLayers, QueryTriggerInteraction.Ignore))
                {
                    if (!IsValidForOwnerCheck(owner, potentialTarget.transform))
                        continue;

                    Vector3 hitPoint = potentialTarget.ClosestPoint(origin);
                    if (!IsValidForObstructionCheck(origin, potentialTarget.transform, hitPoint))
                        continue;

                    Vector3 hitNormal = (owner.transform.position - hitPoint).normalized;
                    Vector3 hitForward = owner.transform.up;

                    //yield return potentialTarget.transform;
                    callback?.Invoke(owner, new ActionHitInformation(potentialTarget.transform, hitPoint, hitNormal, hitForward));
                }
            }
        }
        [System.Serializable]
        private class LineAoETargeting : AoETargeting
        {
            public override string GetRangeString(string distanceUnits) => _lineLength + distanceUnits + " Long " + _lineRadius + distanceUnits + " Wide Line";

            [SerializeField] private float _lineLength;
            [SerializeField] private float _lineRadius;

            public override void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, Action<ServerCharacter, ActionHitInformation> callback)
            {
                // Thick Raycast (Spherecast).
                float length = ScaleRadiusWithChargePercentage ? _lineLength * chargePercentage : _lineLength;
                float radius = ScaleRadiusWithChargePercentage ? _lineRadius * chargePercentage : _lineRadius;
                foreach (RaycastHit potentialTarget in Physics.SphereCastAll(origin, length, direction, radius, ValidLayers, QueryTriggerInteraction.Ignore))
                {
                    Vector3 hitPoint = potentialTarget.point;
                    Vector3 hitNormal = potentialTarget.normal;

                    if (hitPoint == Vector3.zero && hitNormal == -direction)
                    {
                        // The collider was overlapping with the spherecast when it started, so has invalid 'point' and 'normal' data.
                        hitPoint = potentialTarget.collider.ClosestPoint(origin);
                        hitNormal = (origin - hitPoint).normalized;
                    }

                    if (!IsValidForOwnerCheck(owner, potentialTarget.transform) || !IsValidForObstructionCheck(origin, potentialTarget.transform, hitPoint))
                        continue;

                    callback?.Invoke(owner, new ActionHitInformation(potentialTarget.transform, hitPoint, hitNormal, potentialTarget.transform.up));
                }

                // Helper function for calculating our HitForward from a given Normal.
                //Vector3 GetHitForward(in Vector3 hitNormal) => (Mathf.Approximately(Mathf.Abs(Vector3.Dot(hitNormal, direction)), 1.0f) ? Vector3.Cross(hitNormal, -owner.transform.right) : Vector3.Cross(hitNormal, direction)).normalized;
            }
        }
        [System.Serializable]
        private class ConeAoETargeting : AoETargeting
        {
            public override string GetRangeString(string distanceUnits) => _coneLength + distanceUnits + " Long " + _coneAngle + "d Angle Cone";
            [SerializeField] private float _coneLength;
            [SerializeField] private float _coneAngle;

            public override void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, Action<ServerCharacter, ActionHitInformation> callback)
            {
                // OverlapSphere with Angle Check.
                float coneLength = ScaleRadiusWithChargePercentage ? _coneLength * chargePercentage : _coneLength;
                float halfAngle = ((ScaleRadiusWithChargePercentage ? _coneAngle * chargePercentage : _coneAngle) / 2.0f);
                foreach (Collider potentialTarget in Physics.OverlapSphere(origin, coneLength, ValidLayers, QueryTriggerInteraction.Ignore))
                {
                    if (!IsValidForOwnerCheck(owner, potentialTarget.transform))
                        continue;

                    // Angle Check (Makes it a cone rather than a sphere).
                    if (Vector3.Angle(direction, (potentialTarget.transform.position - origin).normalized) > halfAngle)
                        continue;

                    Vector3 hitPoint = potentialTarget.ClosestPoint(origin);
                    if (!IsValidForObstructionCheck(origin, potentialTarget.transform, hitPoint))
                        continue;

                    Vector3 hitNormal = (owner.transform.position - hitPoint).normalized;
                    Vector3 hitForward = owner.transform.up;

                    //yield return potentialTarget.transform;
                    callback?.Invoke(owner, new ActionHitInformation(potentialTarget.transform, hitPoint, hitNormal, hitForward));
                }
            }
        }
    }
}